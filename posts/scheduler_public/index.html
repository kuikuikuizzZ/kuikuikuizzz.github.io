<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Kubernetes Scheduler 源码分析 - 打怪實錄</title><meta name="Description" content=""><meta property="og:title" content="Kubernetes Scheduler 源码分析" />
<meta property="og:description" content="Kubernetes Scheduler ​ 最近在看 k8s 调度相关的一些内容，希望给自己这阵子了解的知识进行一个整理，会连载几篇文章，都会关于调度的，初步的想法是 kubernetes 的默认调度器，然后" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kuikuikuizzz.github.io/posts/scheduler_public/" />
<meta property="article:published_time" content="2021-01-16T11:06:54+08:00" />
<meta property="article:modified_time" content="2021-01-16T11:06:54+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kubernetes Scheduler 源码分析"/>
<meta name="twitter:description" content="Kubernetes Scheduler ​ 最近在看 k8s 调度相关的一些内容，希望给自己这阵子了解的知识进行一个整理，会连载几篇文章，都会关于调度的，初步的想法是 kubernetes 的默认调度器，然后"/>
<meta name="application-name" content="打怪實錄">
<meta name="apple-mobile-web-app-title" content="打怪實錄"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://kuikuikuizzz.github.io/posts/scheduler_public/" /><link rel="prev" href="https://kuikuikuizzz.github.io/posts/horovod_public/" /><link rel="next" href="https://kuikuikuizzz.github.io/posts/scheduler_framework/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Kubernetes Scheduler 源码分析",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/kuikuikuizzz.github.io\/posts\/scheduler_public\/"
        },"genre": "posts","wordcount":  8480 ,
        "url": "https:\/\/kuikuikuizzz.github.io\/posts\/scheduler_public\/","datePublished": "2021-01-16T11:06:54+08:00","dateModified": "2021-01-16T11:06:54+08:00","publisher": {
            "@type": "Organization",
            "name": "kuikuikuizzZ"},"author": {
                "@type": "Person",
                "name": "kuikuikuizzZ"
            },"description": ""
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="打怪實錄">打怪實錄</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="打怪實錄">打怪實錄</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Kubernetes Scheduler 源码分析</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>kuikuikuizzZ</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-01-16">2021-01-16</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 8480 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 17 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#工作原理">工作原理</a>
      <ul>
        <li><a href="#调度器架构">调度器架构</a></li>
        <li><a href="#工作流程">工作流程</a></li>
      </ul>
    </li>
    <li><a href="#setup源码分析">Setup源码分析</a>
      <ul>
        <li><a href="#optconfig">opt.config</a></li>
        <li><a href="#schedulernew">scheduler.New</a></li>
      </ul>
    </li>
    <li><a href="#run源码分析">Run源码分析</a>
      <ul>
        <li><a href="#scheduleonepart1">scheduleOnePart1</a></li>
        <li><a href="#scheduleonepart2">scheduleOnePart2</a></li>
        <li><a href="#scheduleonepart3">scheduleOnePart3</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="kubernetes-scheduler">Kubernetes Scheduler</h1>
<p>​　　最近在看 k8s 调度相关的一些内容，希望给自己这阵子了解的知识进行一个整理，会连载几篇文章，都会关于调度的，初步的想法是 kubernetes 的默认调度器，然后是新引入的 scheduler framework，然后是 kube-batch 和 volcano， 如果还有时间会对这些内容做一个整体性的总结，和我自己的一些看法。这里是第一篇 kubenetes 的默认调度器。</p>
<p>​　　Kubernetes Scheduler 是 Kubernetes 的核心组件之一，主要根据一些调度算法，将没有调度将 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener noreffer">Pod</a> 放置到合适的 <a href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/" target="_blank" rel="noopener noreffer">Node</a> 上，然后对应 Node 上的 <a href="https://kubernetes.io/docs/reference/generated/kubelet" target="_blank" rel="noopener noreffer">Kubelet</a> 才能够运行这些 pod。可以认为 scheduler 就是集群负载的管理者，针对用户或者组件创建的 pod 的负载，为其在集群中找到一个合适的节点，然后让对应节点的 kubelet 服务进程将其运行起来。这篇文章的结构大概是这样的，我们先会从宏观上去看一下 scheduler 的工作原理，然后到每一个部分看一下对应关键代码的实现，其中会尝试去穿插一些我了解到的 scheduler 的版本迭代的过程，然后是一些思考和展望。为了方便复现和讲解，下面对kube-scheduler 代码的分析使用的是 kubernetes 的 v1.19.1 的版本的代码，如果是谈到其他版本也会在其中标注起来。</p>
<h2 id="工作原理">工作原理</h2>
<p>　　Kubernetes 默认的调度器就在 <a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener noreffer">kubernetes</a> 的 repos 中，跟其他的组件一样，都是把入口放在 cmd/kube-schduler 中，把实现放在 pkg/scheduler 中，也是用 cobra 命令行工具启动，我们先看一下，整体的架构。然后会从源码的角度一步步看其调用分析。</p>
<h3 id="调度器架构">调度器架构</h3>
<p>调度器结构体主要的部分如下：pkg/scheduler/scheduler.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Scheduler</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="c1">// 主要是缓存现在集群调度的状态，如上图所示，会保留集群中所有已调度 pod 的状态，node 的状态，和assumedpod，防止 pod 被重新调度。
</span><span class="c1"></span>   <span class="nx">SchedulerCache</span> <span class="nx">internalcache</span><span class="p">.</span><span class="nx">Cache</span>
	 <span class="c1">// Algorithm 需要实现 Schedule 的方法，输入一个 pod 可以找到合适 node。默认是通过   
</span><span class="c1"></span>   <span class="c1">// pkg/scheduler/core/generic_scheduler.go 的 generic_scheduler 实现的。
</span><span class="c1"></span>   <span class="nx">Algorithm</span> <span class="nx">core</span><span class="p">.</span><span class="nx">ScheduleAlgorithm</span>
	 <span class="c1">// 获取下一个 pod
</span><span class="c1"></span>   <span class="nx">NextPod</span> <span class="kd">func</span><span class="p">()</span> <span class="o">*</span><span class="nx">framework</span><span class="p">.</span><span class="nx">QueuedPodInfo</span>

   <span class="c1">// Error is called if there is an error. It is passed the pod in
</span><span class="c1"></span>   <span class="c1">// question, and the error
</span><span class="c1"></span>   <span class="nx">Error</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">framework</span><span class="p">.</span><span class="nx">QueuedPodInfo</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

   <span class="c1">// Close this to shut down the scheduler.
</span><span class="c1"></span>   <span class="nx">StopEverything</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>

   <span class="c1">// SchedulingQueue 会保留准备调度的 pod 的队列。
</span><span class="c1"></span>   <span class="nx">SchedulingQueue</span> <span class="nx">internalqueue</span><span class="p">.</span><span class="nx">SchedulingQueue</span>

   <span class="c1">// 所有的 plugin 都会以 profile 的形式供默认调度器使用
</span><span class="c1"></span>   <span class="nx">Profiles</span> <span class="nx">profile</span><span class="p">.</span><span class="nx">Map</span>

   <span class="nx">scheduledPodsHasSynced</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span>
	 <span class="c1">// 用于和 api-server 的通信
</span><span class="c1"></span>   <span class="nx">client</span> <span class="nx">clientset</span><span class="p">.</span><span class="nx">Interface</span>
<span class="p">}</span>
</code></pre></div><p>​　　下图是我自己对 scheduler 架构的理解，调度主要的工作通过 informer  watch 有没有没有调度的 pod，如果有会尝试找一个合适的 node，然后把 pod 和 node 的 binding 写回给 apiserver。集群状态的信息保留在 schedulerCache 中，集群未调度的 pod 在 schedulingQueue 中。这里只拎出Algorithm，SchedulerCache，SchedulingQueue 来介绍，Profiles 主要是跟 plugins 相关的组件，后面会找在 scheduler framework 中介绍。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="scheduler_design.png"
        data-srcset="/posts/scheduler_public/scheduler_design.png, scheduler_design.png 1.5x, /posts/scheduler_public/scheduler_design.png 2x"
        data-sizes="auto"
        alt="/posts/scheduler_public/scheduler_design.png"
        title="scheduler_design" /></p>
<h3 id="工作流程">工作流程</h3>
<ul>
<li>首先 SchedulerCache 会通过 Informer 读取现在集群的 node, pod 的状态，缓存在内存中。同时监控集群资源状态（如果有创建 node 等事件发生也会及时同步） ，SchedulingQueue 会同时也会运行两个进程，分别定时把 BackoffQ 和 UnschedulabelQ 的 Pod 刷进去 activeQ 中。其中 activeQ 是通过heap 实现的待调度优先队列，BackoffQ ，UnschedulabelQ 顾名思义，是调度出错和不可调度队列，</li>
<li>如果有创建 pod 等事件的发生，且 pod 没有被调度过，会直接进入  SchedulingQueue 的 activeQ 队列中。如果已经调度了，就会进入 schedulerCache 中，把信息缓存起来。</li>
<li>scheduler 主进程会轮询地执行 scheduleOne 的流程
<ul>
<li>通过 NextPod 接口从 activeQ 中读取入队 pod 的信息。</li>
<li>然后通过 Algorithm (通过 pkg/scheduler/core/generic_scheduler 实现) 为这个 pod 尝试找到一个合适 node 进行调度，如果这一步失败了，如果设置了可以抢占会触发抢占，不过这里先不涉及，这样这个 pod 会进入 UnschedulabelQ 的队列中。</li>
<li>如果调度成功会触发一次 assume，主要是在 cache 中记录这个 pod 为已经调度了，这样下次调度的时候就不会重新调度一次这个 pod。因为 assume 后面 scheduleOne 会起一个 goroutine 来负责 binding 的工作。scheduleOne 会跑下一个循环，如果没有 assume，可能导致 node 的资源会被重新使用等问题。</li>
<li>binding 会通知 apiserver pod 和 node 的 binding 已经创建，让 api-server 通知 node 的 kubelet 去配置相应的环境，如（网络，存储等），如果 bind 成功。schedulerCache 会有一个进程 cleanupAssumedPods 不断地看这个pod 是否已经 binding 完成或者超时了，如果 binding 完成会去除这个 assume 的标志。</li>
</ul>
</li>
<li>另外在 schedulingQueue 中，如上图的右侧部分，会起两个goroutine，flushUnschedulableQLeftover 会不断定时把之前调度失败的(UnschedulableQ) 送到 activeQ 中，flushUnschedulableQLeftover 会把出错的pod在 backoffQ 中往 activeQ刷。</li>
<li>schedulerCache 也会起一个 goroutine，会不断地把清理已经调度的，或者超时的 assume pod。</li>
</ul>
<h2 id="setup源码分析">Setup源码分析</h2>
<p>​　　这里我会尝试以一种尽可能详尽（啰嗦）的方式去介绍 kube-scheduler 的源码实现，中间会穿插一下，我对 scheduler 版本迭代的一些理解。我们会从  cmd/kube-scheduler/app/server.go 开始说起。</p>
<p>　　在 cmd/kube-scheduler/app/server.go 中，会通过 cobra 命令行定义 scheduler 的启动命令，最终是运行 cmd/kube-scheduler/app/server.go 中 runCommand 定义的逻辑，调用 Setup 函数，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runCommand runs the scheduler.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runCommand</span><span class="p">(</span><span class="nx">cmd</span> <span class="o">*</span><span class="nx">cobra</span><span class="p">.</span><span class="nx">Command</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">*</span><span class="nx">options</span><span class="p">.</span><span class="nx">Options</span><span class="p">,</span> <span class="nx">registryOptions</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="o">...</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
    <span class="c1">// Setup scheduler
</span><span class="c1"></span>	<span class="nx">cc</span><span class="p">,</span> <span class="nx">sched</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">Setup</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">opts</span><span class="p">,</span> <span class="nx">registryOptions</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">opts</span><span class="p">.</span><span class="nx">WriteConfigTo</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
     <span class="c1">// Run scheduler
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">sched</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Setup 实现
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Setup</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">*</span><span class="nx">options</span><span class="p">.</span><span class="nx">Options</span><span class="p">,</span> <span class="nx">outOfTreeRegistryOptions</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">schedulerserverconfig</span><span class="p">.</span><span class="nx">CompletedConfig</span><span class="p">,</span> <span class="o">*</span><span class="nx">scheduler</span><span class="p">.</span><span class="nx">Scheduler</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">errs</span> <span class="o">:=</span> <span class="nx">opts</span><span class="p">.</span><span class="nf">Validate</span><span class="p">();</span> <span class="nb">len</span><span class="p">(</span><span class="nx">errs</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">utilerrors</span><span class="p">.</span><span class="nf">NewAggregate</span><span class="p">(</span><span class="nx">errs</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="c1">// 1.初始化 client, EventBroadcaster,PodInformer,InformerFactory 并通过 config 回传。
</span><span class="c1"></span>   <span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">opts</span><span class="p">.</span><span class="nf">Config</span><span class="p">()</span>
   <span class="o">...</span>
   <span class="c1">// Get the completed config
</span><span class="c1"></span>   <span class="nx">cc</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Complete</span><span class="p">()</span>

   <span class="nx">outOfTreeRegistry</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">Registry</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">option</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">outOfTreeRegistryOptions</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">option</span><span class="p">(</span><span class="nx">outOfTreeRegistry</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="nx">recorderFactory</span> <span class="o">:=</span> <span class="nf">getRecorderFactory</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cc</span><span class="p">)</span>
   <span class="c1">// 2.Create the scheduler.
</span><span class="c1"></span>   <span class="nx">sched</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">scheduler</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span>
      <span class="nx">cc</span><span class="p">.</span><span class="nx">InformerFactory</span><span class="p">,</span>
      <span class="nx">cc</span><span class="p">.</span><span class="nx">PodInformer</span><span class="p">,</span>
      <span class="nx">recorderFactory</span><span class="p">,</span>
      <span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">(),</span>
      <span class="nx">scheduler</span><span class="p">.</span><span class="nf">WithProfiles</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">Profiles</span><span class="o">...</span><span class="p">),</span>
      <span class="nx">scheduler</span><span class="p">.</span><span class="nf">WithAlgorithmSource</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">AlgorithmSource</span><span class="p">),</span>
      <span class="nx">scheduler</span><span class="p">.</span><span class="nf">WithPercentageOfNodesToScore</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">PercentageOfNodesToScore</span><span class="p">),</span>
      <span class="nx">scheduler</span><span class="p">.</span><span class="nf">WithFrameworkOutOfTreeRegistry</span><span class="p">(</span><span class="nx">outOfTreeRegistry</span><span class="p">),</span>
      <span class="nx">scheduler</span><span class="p">.</span><span class="nf">WithPodMaxBackoffSeconds</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">PodMaxBackoffSeconds</span><span class="p">),</span>
      <span class="nx">scheduler</span><span class="p">.</span><span class="nf">WithPodInitialBackoffSeconds</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">PodInitialBackoffSeconds</span><span class="p">),</span>
      <span class="nx">scheduler</span><span class="p">.</span><span class="nf">WithExtenders</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">ComponentConfig</span><span class="p">.</span><span class="nx">Extenders</span><span class="o">...</span><span class="p">),</span>
   <span class="p">)</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

   <span class="k">return</span> <span class="o">&amp;</span><span class="nx">cc</span><span class="p">,</span> <span class="nx">sched</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>Setup 函数主要干了几件事。</p>
<h3 id="optconfig">opt.config</h3>
<p>Setup 函数中，opt.Config() 主要做了下面几件事：</p>
<ol>
<li>createClients 启动 clientset</li>
<li>events.NewEventBroadcasterAdapter(eventClient) 启动  EventBroadcaster</li>
<li>c.InformerFactory = informers.NewSharedInformerFactory(client, 0) 启动 informer</li>
</ol>
<p>上面这几步基本所有的 kubernetes 的组件基本都是有的，保证组件跟 api-server 的通信。</p>
<h3 id="schedulernew">scheduler.New</h3>
<p>然后 scheduler.New 启动 scheduler 实例：</p>
<p>pkg/scheduler/scheduler.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// New returns a Scheduler
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">client</span> <span class="nx">clientset</span><span class="p">.</span><span class="nx">Interface</span><span class="p">,</span>
   	<span class="nx">informerFactory</span> <span class="nx">informers</span><span class="p">.</span><span class="nx">SharedInformerFactory</span><span class="p">,</span>
   	<span class="nx">podInformer</span> <span class="nx">coreinformers</span><span class="p">.</span><span class="nx">PodInformer</span><span class="p">,</span>
   	<span class="nx">recorderFactory</span> <span class="nx">profile</span><span class="p">.</span><span class="nx">RecorderFactory</span><span class="p">,</span>
   	<span class="nx">stopCh</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span>
   	<span class="nx">opts</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Scheduler</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   	<span class="o">...</span> <span class="c1">// some config
</span><span class="c1"></span>   	<span class="c1">// 初始化 schedulerCache
</span><span class="c1"></span>   	<span class="nx">schedulerCache</span> <span class="o">:=</span> <span class="nx">internalcache</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mi">30</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="nx">stopEverything</span><span class="p">)</span>
	<span class="c1">// 注册 intree 的 plugins
</span><span class="c1"></span>   	<span class="nx">registry</span> <span class="o">:=</span> <span class="nx">frameworkplugins</span><span class="p">.</span><span class="nf">NewInTreeRegistry</span><span class="p">()</span>
   	<span class="o">...</span>
   	<span class="c1">// 初始化 snapshot
</span><span class="c1"></span>   	<span class="nx">snapshot</span> <span class="o">:=</span> <span class="nx">internalcache</span><span class="p">.</span><span class="nf">NewEmptySnapshot</span><span class="p">()</span>

   	<span class="nx">configurator</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Configurator</span><span class="p">{</span>
      <span class="nx">client</span><span class="p">:</span>                   <span class="nx">client</span><span class="p">,</span>
      <span class="nx">recorderFactory</span><span class="p">:</span>          <span class="nx">recorderFactory</span><span class="p">,</span>
      <span class="nx">informerFactory</span><span class="p">:</span>          <span class="nx">informerFactory</span><span class="p">,</span>
      <span class="nx">podInformer</span><span class="p">:</span>              <span class="nx">podInformer</span><span class="p">,</span>
      <span class="nx">schedulerCache</span><span class="p">:</span>           <span class="nx">schedulerCache</span><span class="p">,</span>
	  <span class="o">...</span>
      <span class="nx">registry</span><span class="p">:</span>                 <span class="nx">registry</span><span class="p">,</span>
      <span class="nx">nodeInfoSnapshot</span><span class="p">:</span>         <span class="nx">snapshot</span><span class="p">,</span>
      <span class="o">...</span>
   	<span class="p">}</span>
   	<span class="o">...</span>
   	<span class="kd">var</span> <span class="nx">sched</span> <span class="o">*</span><span class="nx">Scheduler</span>
   	<span class="c1">// 通过上面 configurator 创建 scheduler(sched) 
</span><span class="c1"></span>   	<span class="c1">// 可以通过 policy 或者 provider 创建
</span><span class="c1"></span>    <span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">source</span><span class="p">.</span><span class="nx">Provider</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">:</span>
		<span class="c1">// Create the config from a named algorithm provider.
</span><span class="c1"></span>		<span class="nx">sc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">configurator</span><span class="p">.</span><span class="nf">createFromProvider</span><span class="p">(</span><span class="o">*</span><span class="nx">source</span><span class="p">.</span><span class="nx">Provider</span><span class="p">)</span>
        <span class="o">...</span>
	<span class="k">case</span> <span class="nx">source</span><span class="p">.</span><span class="nx">Policy</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">:</span>
		<span class="c1">// Create the config from a user specified policy source.
</span><span class="c1"></span>		<span class="nx">policy</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">schedulerapi</span><span class="p">.</span><span class="nx">Policy</span><span class="p">{}</span>
		<span class="k">switch</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">source</span><span class="p">.</span><span class="nx">Policy</span><span class="p">.</span><span class="nx">File</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">:</span>
			<span class="nf">initPolicyFromFile</span><span class="p">(</span><span class="nx">source</span><span class="p">.</span><span class="nx">Policy</span><span class="p">.</span><span class="nx">File</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span> <span class="nx">policy</span><span class="p">)</span>
		<span class="p">}</span>
        <span class="o">...</span>
    <span class="p">}</span>
   	<span class="o">...</span>
   	<span class="nf">addAllEventHandlers</span><span class="p">(</span><span class="nx">sched</span><span class="p">,</span> <span class="nx">informerFactory</span><span class="p">,</span> <span class="nx">podInformer</span><span class="p">)</span>
   	<span class="k">return</span> <span class="nx">sched</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><ol>
<li>
<p>schedulerCache = internalcache.New(30*time.Second, stopEverything) 启动 scheduler 的缓存，主要是会启动 pkg/scheduler/internal/cache/cache.go:cleanupAssumedPods 这个函数定期清理AssumedPods。</p>
</li>
<li>
<p>registry := frameworkplugins.NewInTreeRegistry() 会读取所有 intree 的 plugins 注册掉，譬如：注册interpodaffinity 的调度算法，这种 plugin 的注册方式是通过 v1.15 开始引入的 scheduler  framework 实现的，我们这里不深入。</p>
</li>
<li>
<p>初始化 Snapshot，初始化一个 map 保存 node 信息，是用在 Algorithm.Schedule 的过程中的，主要是保留一份 cache 的备份</p>
</li>
<li>
<p>Configurator 是scheduler 的配置器，创建 scheduler(sched) 可以通过  configurator.createFromConfig(*policy) 或者 configurator.createFromProvider(*source.Provider) 来进行，不过无论使用哪种方式创建都会调用 configurator.create() 函数：</p>
<ul>
<li>初始化profiles(plugin)</li>
<li>初始化 SchedulingQueue</li>
<li>用 NewGenericScheduler 实例化 Algorithm</li>
</ul>
<p>至此，scheduler 的初始化工作基本完成了。</p>
<p>pkg/scheduler/core/generic_scheduler.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// create a scheduler from a set of registered plugins.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Configurator</span><span class="p">)</span> <span class="nf">create</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">Scheduler</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">extenders</span> <span class="p">[]</span><span class="nx">framework</span><span class="p">.</span><span class="nx">Extender</span>
   <span class="kd">var</span> <span class="nx">ignoredExtendedResources</span> <span class="p">[]</span><span class="kt">string</span>
   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">extenders</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
     <span class="o">...</span> <span class="c1">// 如果有 extenders
</span><span class="c1"></span>   <span class="p">}</span>
   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ignoredExtendedResources</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
     <span class="o">...</span> <span class="c1">// 对 ignoredExtendedResources 有一些处理 
</span><span class="c1"></span>   <span class="p">}</span>
     <span class="o">...</span>
   <span class="c1">// 初始化 profiles
</span><span class="c1"></span>   <span class="nx">profiles</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">profile</span><span class="p">.</span><span class="nf">NewMap</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">profiles</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">buildFramework</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recorderFactory</span><span class="p">,</span>
      <span class="nx">frameworkruntime</span><span class="p">.</span><span class="nf">WithPodNominator</span><span class="p">(</span><span class="nx">nominator</span><span class="p">))</span>
   <span class="c1">// 初始化队列优先级函数
</span><span class="c1"></span>   <span class="nx">lessFn</span> <span class="o">:=</span> <span class="nx">profiles</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">profiles</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">SchedulerName</span><span class="p">].</span><span class="nx">Framework</span><span class="p">.</span><span class="nf">QueueSortFunc</span><span class="p">()</span>
   <span class="c1">// 初始化调度队列，需要优先级函数，和定义 backoffQ,UnScheduableQ 刷回 activeQ 的周期参数 
</span><span class="c1"></span>   <span class="nx">podQueue</span> <span class="o">:=</span> <span class="nx">internalqueue</span><span class="p">.</span><span class="nf">NewSchedulingQueue</span><span class="p">(</span>
      <span class="nx">lessFn</span><span class="p">,</span>
      <span class="nx">internalqueue</span><span class="p">.</span><span class="nf">WithPodInitialBackoffDuration</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">podInitialBackoffSeconds</span><span class="p">)</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
      <span class="nx">internalqueue</span><span class="p">.</span><span class="nf">WithPodMaxBackoffDuration</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">podMaxBackoffSeconds</span><span class="p">)</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">),</span>
      <span class="nx">internalqueue</span><span class="p">.</span><span class="nf">WithPodNominator</span><span class="p">(</span><span class="nx">nominator</span><span class="p">),</span>
   <span class="p">)</span>
   <span class="c1">// 使用 NewGenericScheduler 初始化 Algorithm
</span><span class="c1"></span>   <span class="nx">algo</span> <span class="o">:=</span> <span class="nx">core</span><span class="p">.</span><span class="nf">NewGenericScheduler</span><span class="p">(</span>
      <span class="nx">c</span><span class="p">.</span><span class="nx">schedulerCache</span><span class="p">,</span>
      <span class="nx">c</span><span class="p">.</span><span class="nx">nodeInfoSnapshot</span><span class="p">,</span>
      <span class="nx">extenders</span><span class="p">,</span>
      <span class="nx">c</span><span class="p">.</span><span class="nx">informerFactory</span><span class="p">.</span><span class="nf">Core</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">PersistentVolumeClaims</span><span class="p">().</span><span class="nf">Lister</span><span class="p">(),</span>
      <span class="nx">c</span><span class="p">.</span><span class="nx">disablePreemption</span><span class="p">,</span>
      <span class="nx">c</span><span class="p">.</span><span class="nx">percentageOfNodesToScore</span><span class="p">,</span>
   <span class="p">)</span>
   
   <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Scheduler</span><span class="p">{</span>
      <span class="nx">SchedulerCache</span><span class="p">:</span>  <span class="nx">c</span><span class="p">.</span><span class="nx">schedulerCache</span><span class="p">,</span>
      <span class="nx">Algorithm</span><span class="p">:</span>       <span class="nx">algo</span><span class="p">,</span>
      <span class="nx">Profiles</span><span class="p">:</span>        <span class="nx">profiles</span><span class="p">,</span>
      <span class="nx">NextPod</span><span class="p">:</span>         <span class="nx">internalqueue</span><span class="p">.</span><span class="nf">MakeNextPodFunc</span><span class="p">(</span><span class="nx">podQueue</span><span class="p">),</span>
      <span class="nx">Error</span><span class="p">:</span>           <span class="nf">MakeDefaultErrorFunc</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">client</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">informerFactory</span><span class="p">.</span><span class="nf">Core</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">Pods</span><span class="p">().</span><span class="nf">Lister</span><span class="p">(),</span> <span class="nx">podQueue</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">schedulerCache</span><span class="p">),</span>
      <span class="nx">StopEverything</span><span class="p">:</span>  <span class="nx">c</span><span class="p">.</span><span class="nx">StopEverything</span><span class="p">,</span>
      <span class="nx">SchedulingQueue</span><span class="p">:</span> <span class="nx">podQueue</span><span class="p">,</span>
   <span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>addAllEventHandlers 为 scheduler 提供 eventHandler，如上面架构图所示：event 的接收者主要有两个，SchedulerCache 和 SchedulingQueue，前者是为了跟踪集群的资源和已调度 Pod 的状态（addNodeToCache，addPodToCache），后者主要是给没有调度的 Pod 入队到 activeQ 中（addPodToSchedulingQueue）。这里重点说一下，scheduler 算是在这里完成第一次的过滤。如果是未调度的pod，会经过 event 的过滤器，其中 assignedPod(t) 会看 pod.Spec.NodeName 判断 pod 是不是已经调度或者 assume 了，responsibleForPod(t, sched.Profiles) 会看 pod.Spec.SchedulerName 看一下调度器名字是不是本调度器。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="eventHandler.png"
        data-srcset="/posts/scheduler_public/eventHandler.png, eventHandler.png 1.5x, /posts/scheduler_public/eventHandler.png 2x"
        data-sizes="auto"
        alt="/posts/scheduler_public/eventHandler.png"
        title="eventHandler" /></p>
<p>pkg/scheduler/eventhandlers.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// addAllEventHandlers is a helper function used in tests and in Scheduler
</span><span class="c1">// to add event handlers for various informers.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">addAllEventHandlers</span><span class="p">(</span>
   <span class="nx">sched</span> <span class="o">*</span><span class="nx">Scheduler</span><span class="p">,</span>
   <span class="nx">informerFactory</span> <span class="nx">informers</span><span class="p">.</span><span class="nx">SharedInformerFactory</span><span class="p">,</span>
   <span class="nx">podInformer</span> <span class="nx">coreinformers</span><span class="p">.</span><span class="nx">PodInformer</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
   <span class="c1">// scheduled pod cache
</span><span class="c1"></span>   <span class="nx">podInformer</span><span class="p">.</span><span class="nf">Informer</span><span class="p">().</span><span class="nf">AddEventHandler</span><span class="p">(</span>
      <span class="nx">cache</span><span class="p">.</span><span class="nx">FilteringResourceEventHandler</span><span class="p">{</span>
         <span class="nx">FilterFunc</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="nx">t</span> <span class="o">:=</span> <span class="nx">obj</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">:</span>
               <span class="k">return</span> <span class="nf">assignedPod</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
            <span class="k">case</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">DeletedFinalStateUnknown</span><span class="p">:</span>
               <span class="o">...</span>
            <span class="k">default</span><span class="p">:</span>
               <span class="o">...</span>
            <span class="p">}</span>
         <span class="p">},</span>
         <span class="nx">Handler</span><span class="p">:</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">ResourceEventHandlerFuncs</span><span class="p">{</span>
            <span class="nx">AddFunc</span><span class="p">:</span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">addPodToCache</span><span class="p">,</span>
            <span class="nx">UpdateFunc</span><span class="p">:</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">updatePodInCache</span><span class="p">,</span>
            <span class="nx">DeleteFunc</span><span class="p">:</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deletePodFromCache</span><span class="p">,</span>
         <span class="p">},</span>
      <span class="p">},</span>
   <span class="p">)</span>
   <span class="c1">// unscheduled pod queue
</span><span class="c1"></span>   <span class="nx">podInformer</span><span class="p">.</span><span class="nf">Informer</span><span class="p">().</span><span class="nf">AddEventHandler</span><span class="p">(</span>
      <span class="nx">cache</span><span class="p">.</span><span class="nx">FilteringResourceEventHandler</span><span class="p">{</span>
         <span class="nx">FilterFunc</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="nx">t</span> <span class="o">:=</span> <span class="nx">obj</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">:</span>
               <span class="k">return</span> <span class="p">!</span><span class="nf">assignedPod</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">responsibleForPod</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">Profiles</span><span class="p">)</span>
            <span class="k">case</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">DeletedFinalStateUnknown</span><span class="p">:</span>
               <span class="o">...</span>
            <span class="k">default</span><span class="p">:</span>
               <span class="o">...</span>
            <span class="p">}</span>
         <span class="p">},</span>
         <span class="nx">Handler</span><span class="p">:</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">ResourceEventHandlerFuncs</span><span class="p">{</span>
            <span class="nx">AddFunc</span><span class="p">:</span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">addPodToSchedulingQueue</span><span class="p">,</span>
            <span class="nx">UpdateFunc</span><span class="p">:</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">updatePodInSchedulingQueue</span><span class="p">,</span>
            <span class="nx">DeleteFunc</span><span class="p">:</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deletePodFromSchedulingQueue</span><span class="p">,</span>
         <span class="p">},</span>
      <span class="p">},</span>
   <span class="p">)</span>
   
   <span class="nx">informerFactory</span><span class="p">.</span><span class="nf">Core</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">Nodes</span><span class="p">().</span><span class="nf">Informer</span><span class="p">().</span><span class="nf">AddEventHandler</span><span class="p">(</span>
      <span class="nx">cache</span><span class="p">.</span><span class="nx">ResourceEventHandlerFuncs</span><span class="p">{</span>
         <span class="nx">AddFunc</span><span class="p">:</span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">addNodeToCache</span><span class="p">,</span>
         <span class="nx">UpdateFunc</span><span class="p">:</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">updateNodeInCache</span><span class="p">,</span>
         <span class="nx">DeleteFunc</span><span class="p">:</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deleteNodeFromCache</span><span class="p">,</span>
      <span class="p">},</span>
   <span class="p">)</span>
   <span class="o">...</span> 
   <span class="nx">informerFactory</span><span class="p">.</span><span class="nf">Core</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">PersistentVolumes</span><span class="p">().</span><span class="nf">Informer</span><span class="p">().</span><span class="nf">AddEventHandler</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>   <span class="nx">informerFactory</span><span class="p">.</span><span class="nf">Core</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">PersistentVolumeClaims</span><span class="p">().</span><span class="nf">Informer</span><span class="p">().</span><span class="nf">AddEventHandler</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
   <span class="nx">informerFactory</span><span class="p">.</span><span class="nf">Core</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">Services</span><span class="p">().</span><span class="nf">Informer</span><span class="p">().</span><span class="nf">AddEventHandler</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="nx">informerFactory</span><span class="p">.</span><span class="nf">Storage</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">StorageClasses</span><span class="p">().</span><span class="nf">Informer</span><span class="p">().</span><span class="nf">AddEventHandler</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
   
<span class="c1">// 看一下是不是已经被调度了
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">assignedPod</span><span class="p">(</span><span class="nx">pod</span> <span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pod</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">NodeName</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>
<span class="c1">// 看一下是不是我们负责的
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">responsibleForPod</span><span class="p">(</span><span class="nx">pod</span> <span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">,</span> <span class="nx">profiles</span> <span class="nx">profile</span><span class="p">.</span><span class="nx">Map</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">profiles</span><span class="p">.</span><span class="nf">HandlesSchedulerName</span><span class="p">(</span><span class="nx">pod</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">SchedulerName</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></li>
</ol>
<p>总结一下，Setup 就是初始化scheduler 的各个部件，包括 informer, schedulerCache, schedulingQueue，和实例化 scheduler。</p>
<h2 id="run源码分析">Run源码分析</h2>
<p>　　runCommand 在执行完 Setup() 之后会调用Run()，Run 主要分几个部分，首先一般都需要先启动 informer 并等待同步完成，表示集群的状态是已知的，然后启动 scheduler.Run()，会把schedulerCache的清理缓存，schedulingQueue 的定时入队，和 scheduler 主流程 scheduleOne 分别用 goroutine 启动。</p>
<p>cmd/kube-scheduler/app/server.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Run executes the scheduler based on the given configuration. It only returns on error or when context is done.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">schedulerserverconfig</span><span class="p">.</span><span class="nx">CompletedConfig</span><span class="p">,</span> <span class="nx">sched</span> <span class="o">*</span><span class="nx">scheduler</span><span class="p">.</span><span class="nx">Scheduler</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
   <span class="o">...</span> <span class="c1">// some config
</span><span class="c1"></span>
   <span class="c1">// Prepare the event broadcaster.
</span><span class="c1"></span>   <span class="nx">cc</span><span class="p">.</span><span class="nx">EventBroadcaster</span><span class="p">.</span><span class="nf">StartRecordingToSink</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">())</span>

   <span class="o">...</span> <span class="c1">// setup 健康检查的服务器.
</span><span class="c1"></span>
   <span class="c1">// Start all informers.
</span><span class="c1"></span>   <span class="k">go</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">PodInformer</span><span class="p">.</span><span class="nf">Informer</span><span class="p">().</span><span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">())</span>
   <span class="nx">cc</span><span class="p">.</span><span class="nx">InformerFactory</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">())</span>

   <span class="c1">// Wait for all caches to sync before scheduling.
</span><span class="c1"></span>   <span class="nx">cc</span><span class="p">.</span><span class="nx">InformerFactory</span><span class="p">.</span><span class="nf">WaitForCacheSync</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">())</span>

   <span class="c1">// 选主逻辑
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">LeaderElection</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
     <span class="o">...</span>
   <span class="p">}</span>
  
   <span class="nx">sched</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
   <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;finished without leader elect&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">sched</span> <span class="o">*</span><span class="nx">Scheduler</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">!</span><span class="nx">cache</span><span class="p">.</span><span class="nf">WaitForCacheSync</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">(),</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">scheduledPodsHasSynced</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span>
   <span class="p">}</span>
   <span class="nx">sched</span><span class="p">.</span><span class="nx">SchedulingQueue</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>
   <span class="nx">wait</span><span class="p">.</span><span class="nf">UntilWithContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">scheduleOne</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
   <span class="nx">sched</span><span class="p">.</span><span class="nx">SchedulingQueue</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>SchedulingQueue.Run() 会起两个 goroutine ，flushBackoffQCompleted 主要负责把所有 backoff 计时完毕（duration 会因为失败变长）的 pod 往 activeQ刷。flushUnschedulableQLeftover 把所有在 unschedulableQ 的 pod  计时unschedulableQTimeInterval 完毕后送去 activeQ。</p>
<h3 id="scheduleonepart1">scheduleOnePart1</h3>
<p>　　scheduleOne 是调度的主逻辑，下面会把 scheduleOne 的逻辑分为3部分，第一部分是调度部分，第二部分是对调度结果进行处理部分（抢占），第三部分是绑定等部分。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="scheduleOne.png"
        data-srcset="/posts/scheduler_public/scheduleOne.png, scheduleOne.png 1.5x, /posts/scheduler_public/scheduleOne.png 2x"
        data-sizes="auto"
        alt="/posts/scheduler_public/scheduleOne.png"
        title="scheduleOne" /></p>
<h4 id="太长不看版">太长不看版</h4>
<ul>
<li>如上图，从schedulingQueue 的待调度队列 activeQ 取出 pod。</li>
<li>进行预选执行 findNodesThatFitPod，会起多个 goroutine 去看 nodeInfo 合不合适，NodeAffinity 也是在这里检查，返回预选 nodes 列表。</li>
<li>进行优选 prioritizedNodes，也会起多个 goroutine 去尝试把待调度的 pod 放到 node 上，计算每个预选的 nodes 的得分，这里会看 node 上现有的 podInfo，podAffinity 也是在这里检查</li>
<li>每个nodes 的得分汇总起来给 selectHost 选出一个合适的 nodes。</li>
</ul>
<h4 id="具体代码细节">具体代码细节</h4>
<p>pkg/scheduler/scheduler.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// scheduleOne does the entire scheduling workflow for a single pod.  It is serialized on the scheduling algorithm&#39;s host fitting.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sched</span> <span class="o">*</span><span class="nx">Scheduler</span><span class="p">)</span> <span class="nf">scheduleOne</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">podInfo</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nf">NextPod</span><span class="p">()</span>
   <span class="c1">// pod could be nil when schedulerQueue is closed
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">podInfo</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">podInfo</span><span class="p">.</span><span class="nx">Pod</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span>
   <span class="p">}</span>
   <span class="nx">pod</span> <span class="o">:=</span> <span class="nx">podInfo</span><span class="p">.</span><span class="nx">Pod</span>
   <span class="c1">// 根据 prof 确定是不是要 skip 这个 pod
</span><span class="c1"></span>   <span class="nx">prof</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nf">profileForPod</span><span class="p">(</span><span class="nx">pod</span><span class="p">)</span>
   <span class="o">...</span>
   <span class="c1">// 调度逻辑
</span><span class="c1"></span>   <span class="nx">scheduleResult</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">Algorithm</span><span class="p">.</span><span class="nf">Schedule</span><span class="p">(</span><span class="nx">schedulingCycleCtx</span><span class="p">,</span> <span class="nx">prof</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">)</span>
   <span class="o">...</span> <span class="c1">// 下面是 Part2
</span><span class="c1"></span>
</code></pre></div><p>ScheudleOne 第一部分的逻辑如上：</p>
<ol>
<li>首先 sched.NextPod() 会调用 scheduler 的 Pop 接口，后面会直接 PriorityQueue.activeQ.Pop()</li>
<li>查看 profile(plugin) 是否负责这个 pod，Profile, err := sched.profileForPod(pod) 【之前版本是 frameworkForPod】 会查看 pod 的 schedulername</li>
<li>skipPodSchedule 有两种情况 skip，(1) pod 正在被删除，(2) pod 被 assumed</li>
<li>scheduleResult, err := sched.Algorithm.Schedule这里会根据提供的算法调用 genericScheduler.Schedule 完成调度，这里需要展开一下。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// pkg/scheduler/core/generic_scheduler.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">genericScheduler</span><span class="p">)</span> <span class="nf">Schedule</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">prof</span> <span class="o">*</span><span class="nx">profile</span><span class="p">.</span><span class="nx">Profile</span><span class="p">,</span> <span class="nx">state</span> <span class="o">*</span><span class="nx">framework</span><span class="p">.</span><span class="nx">CycleState</span><span class="p">,</span> <span class="nx">pod</span> <span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="nx">ScheduleResult</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">...</span> <span class="c1">// some preprocess
</span><span class="c1"></span>   <span class="c1">// 1. 生成这个时刻的 snapshot
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">snapshot</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span>
   <span class="p">}</span>
   <span class="o">...</span>
   <span class="c1">// 2. 对 node 进行预选，过滤出合适的pod
</span><span class="c1"></span>   <span class="nx">feasibleNodes</span><span class="p">,</span> <span class="nx">filteredNodesStatuses</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">findNodesThatFitPod</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">prof</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">feasibleNodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
       <span class="k">return</span> <span class="nx">result</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">FitError</span><span class="p">{</span><span class="o">...</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="o">...</span> <span class="c1">// some metrics
</span><span class="c1"></span>   <span class="c1">// 如果只有一个 node 合适就不会进入优选环节，直接返回
</span><span class="c1"></span>   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">feasibleNodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
	 		<span class="o">...</span> <span class="c1">// some metrics
</span><span class="c1"></span>      <span class="k">return</span> <span class="nx">ScheduleResult</span><span class="p">{</span>
         <span class="nx">SuggestedHost</span><span class="p">:</span>  <span class="nx">feasibleNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Name</span><span class="p">,</span>
         <span class="nx">EvaluatedNodes</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">filteredNodesStatuses</span><span class="p">),</span>
         <span class="nx">FeasibleNodes</span><span class="p">:</span>  <span class="mi">1</span><span class="p">,</span>
      <span class="p">},</span> <span class="kc">nil</span>
   <span class="p">}</span>
   <span class="c1">// 3. 对 node 进行优选
</span><span class="c1"></span>   <span class="nx">priorityList</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">prioritizeNodes</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">prof</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">,</span> <span class="nx">feasibleNodes</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span>
   <span class="p">}</span>
	 <span class="o">...</span> <span class="c1">// some metrics
</span><span class="c1"></span>   <span class="nx">host</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">selectHost</span><span class="p">(</span><span class="nx">priorityList</span><span class="p">)</span>
   <span class="nx">trace</span><span class="p">.</span><span class="nf">Step</span><span class="p">(</span><span class="s">&#34;Prioritizing done&#34;</span><span class="p">)</span>

   <span class="k">return</span> <span class="nx">ScheduleResult</span><span class="p">{</span>
      <span class="nx">SuggestedHost</span><span class="p">:</span>  <span class="nx">host</span><span class="p">,</span>
      <span class="nx">EvaluatedNodes</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nx">feasibleNodes</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">filteredNodesStatuses</span><span class="p">),</span>
      <span class="nx">FeasibleNodes</span><span class="p">:</span>  <span class="nb">len</span><span class="p">(</span><span class="nx">feasibleNodes</span><span class="p">),</span>
   <span class="p">},</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><h5 id="findnodesthatfitpod">FindNodesThatFitPod</h5>
<ol>
<li>
<p>生成一个这个时刻的 snapshot，主要是这个时刻的 nodeInfo map 生成一份快照</p>
</li>
<li>
<p>findNodesThatFitPod 找什么 node 适合这个 pod，针对 node 的信息进行判断，其代码如下。</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//pkg/scheduler/core/generic_scheduler.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">genericScheduler</span><span class="p">)</span> <span class="nf">findNodesThatFitPod</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">prof</span> <span class="o">*</span><span class="nx">profile</span><span class="p">.</span><span class="nx">Profile</span><span class="p">,</span> <span class="nx">state</span> <span class="o">*</span><span class="nx">framework</span><span class="p">.</span><span class="nx">CycleState</span><span class="p">,</span> <span class="nx">pod</span> <span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">framework</span><span class="p">.</span><span class="nx">NodeToStatusMap</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">filteredNodesStatuses</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">framework</span><span class="p">.</span><span class="nx">NodeToStatusMap</span><span class="p">)</span>
<span class="c1">// Run &#34;prefilter&#34; plugins.
</span><span class="c1"></span>       <span class="c1">// 1. 运行预过滤 plugin 逻辑
</span><span class="c1"></span>       <span class="nx">s</span> <span class="o">:=</span> <span class="nx">prof</span><span class="p">.</span><span class="nf">RunPreFilterPlugins</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">)</span>
       <span class="o">...</span> <span class="c1">//错误处理 
</span><span class="c1"></span>       <span class="c1">// 2. 对 nodes 进行过滤，返回 nodes 列表
</span><span class="c1"></span>       <span class="nx">feasibleNodes</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">findNodesThatPassFilters</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">prof</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">,</span> <span class="nx">filteredNodesStatuses</span><span class="p">)</span>
       <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
       <span class="p">}</span>
       <span class="c1">// 3. 运行 extender 过滤逻辑
</span><span class="c1"></span>       <span class="nx">feasibleNodes</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">findNodesThatPassExtenders</span><span class="p">(</span><span class="nx">pod</span><span class="p">,</span> <span class="nx">feasibleNodes</span><span class="p">,</span> <span class="nx">filteredNodesStatuses</span><span class="p">)</span>
       <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
       <span class="p">}</span>
       <span class="k">return</span> <span class="nx">feasibleNodes</span><span class="p">,</span> <span class="nx">filteredNodesStatuses</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><ol>
<li>
<p>prof.RunPreFilterPlugins(ctx, state, pod) 先进行预过滤，主要对 pod 进行。</p>
</li>
<li>
<p>g.findNodesThatPassFilters(ctx, prof, state, pod, filteredNodesStatuses) 这部分会问这个 pod 调度到该 node 合适吗，主要会跟 node 中的 pod 进行亲和性检查等过滤性操作，这里展开一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">genericScheduler</span><span class="p">)</span> <span class="nf">findNodesThatPassFilters</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">prof</span> <span class="o">*</span><span class="nx">profile</span><span class="p">.</span><span class="nx">Profile</span><span class="p">,</span> <span class="nx">state</span> <span class="o">*</span><span class="nx">framework</span><span class="p">.</span><span class="nx">CycleState</span><span class="p">,</span> <span class="nx">pod</span> <span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">,</span> <span class="nx">statuses</span> <span class="nx">framework</span><span class="p">.</span><span class="nx">NodeToStatusMap</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">allNodes</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">nodeInfoSnapshot</span><span class="p">.</span><span class="nf">NodeInfos</span><span class="p">().</span><span class="nf">List</span><span class="p">()</span>
     <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
        <span class="p">}</span>
       <span class="c1">// 1. 选择总共多少个 nodes 尝试去调度
</span><span class="c1"></span><span class="nx">numNodesToFind</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">numFeasibleNodesToFind</span><span class="p">(</span><span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allNodes</span><span class="p">)))</span>
          
     <span class="c1">// Create feasible list with enough space to avoid growing it
</span><span class="c1"></span>     <span class="c1">// and allow assigning.
</span><span class="c1"></span>     <span class="nx">feasibleNodes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">numNodesToFind</span><span class="p">)</span>
       
     <span class="k">if</span> <span class="p">!</span><span class="nx">prof</span><span class="p">.</span><span class="nf">HasFilterPlugins</span><span class="p">()</span> <span class="p">{</span>
 <span class="o">...</span> <span class="c1">//如果没有 filterPlugins, 直接返回所有的 nodes
</span><span class="c1"></span>     <span class="p">}</span>
       
     <span class="nx">errCh</span> <span class="o">:=</span> <span class="nx">parallelize</span><span class="p">.</span><span class="nf">NewErrorChannel</span><span class="p">()</span>
     <span class="kd">var</span> <span class="nx">statusesLock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
     <span class="kd">var</span> <span class="nx">feasibleNodesLen</span> <span class="kt">int32</span>
     <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="c1">// 2. 启动16个 goroutine 并行过滤，
</span><span class="c1"></span>     <span class="nx">checkNode</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">nodeInfo</span> <span class="o">:=</span> <span class="nx">allNodes</span><span class="p">[(</span><span class="nx">g</span><span class="p">.</span><span class="nx">nextStartNodeIndex</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="nx">allNodes</span><span class="p">)]</span>
         <span class="nx">fits</span><span class="p">,</span> <span class="nx">status</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">PodPassesFiltersOnNode</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">prof</span><span class="p">.</span><span class="nf">PreemptHandle</span><span class="p">(),</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">,</span> <span class="nx">nodeInfo</span><span class="p">)</span>
         <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
         <span class="k">if</span> <span class="nx">fits</span> <span class="p">{</span>
             <span class="nx">length</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">feasibleNodesLen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
             <span class="k">if</span> <span class="nx">length</span> <span class="p">&gt;</span> <span class="nx">numNodesToFind</span> <span class="p">{</span>
                 <span class="nf">cancel</span><span class="p">()</span>
                 <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">feasibleNodesLen</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
             <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                 <span class="nx">feasibleNodes</span><span class="p">[</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nodeInfo</span><span class="p">.</span><span class="nf">Node</span><span class="p">()</span>
             <span class="p">}</span>
         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
             <span class="nx">statusesLock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
             <span class="k">if</span> <span class="p">!</span><span class="nx">status</span><span class="p">.</span><span class="nf">IsSuccess</span><span class="p">()</span> <span class="p">{</span>
                 <span class="nx">statuses</span><span class="p">[</span><span class="nx">nodeInfo</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nx">Name</span><span class="p">]</span> <span class="p">=</span> <span class="nx">status</span>
             <span class="p">}</span>
             <span class="nx">statusesLock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
         <span class="p">}</span>
     <span class="p">}</span>
          
     <span class="nx">beginCheckNode</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
     <span class="nx">statusCode</span> <span class="o">:=</span> <span class="nx">framework</span><span class="p">.</span><span class="nx">Success</span>
     <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
     <span class="o">...</span> <span class="c1">// some matrics
</span><span class="c1"></span>       <span class="c1">// 起 16 个goroutine 跑 checkNode
</span><span class="c1"></span>     <span class="nx">parallelize</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allNodes</span><span class="p">),</span> <span class="nx">checkNode</span><span class="p">)</span>
     <span class="nx">processedNodes</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">feasibleNodesLen</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">statuses</span><span class="p">)</span>
     <span class="nx">g</span><span class="p">.</span><span class="nx">nextStartNodeIndex</span> <span class="p">=</span> <span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">nextStartNodeIndex</span> <span class="o">+</span> <span class="nx">processedNodes</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allNodes</span><span class="p">)</span>
          
     <span class="nx">feasibleNodes</span> <span class="p">=</span> <span class="nx">feasibleNodes</span><span class="p">[:</span><span class="nx">feasibleNodesLen</span><span class="p">]</span>
     <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">errCh</span><span class="p">.</span><span class="nf">ReceiveError</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="nx">statusCode</span> <span class="p">=</span> <span class="nx">framework</span><span class="p">.</span><span class="nx">Error</span>
         <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="nx">feasibleNodes</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>这里会定义 numNodesToFind := g.numFeasibleNodesToFind(int32(len(allNodes))) 确定遍历 node 的数目，如果集群太大，遍历所有的 node 是比较耗时的，默认是如果 nodes 数目小于100，会遍历所有 node，如果太多会取百分比。</li>
<li>然后  会通过 parallelize 提供的并发接口调用 checkNode，一般并发数量为 16。checkNode 会调用 PodPassesFiltersOnNode ，会通过 RunFilterPlugins 运行各个 filterplugins 主要是看一下pod 跟在 node 里面的pod 有没有不兼容的关系，查一下优先级是不是equal 或者有比上面的pod 大，如果可以抢占？</li>
<li>checkNode 会返回不同node 的适不适合的信息，如果适合，信息放在一个list 中 feasibleNodes[length-1] = nodeInfo.Node()；如果不适合，在 statuses[nodeInfo.Node().Name] = status 登记错误信息</li>
<li>findNodesThatPassExtenders 会遍历不同 extender，针对不同的资源，Filter(pod, feasibleNodes) 主要也是用户写的custom filter，也是返回 feasibleNodes（ []v1.Node）。</li>
</ul>
</li>
<li>
<p>前面 findNodesThatFitPod 返回了合适 []v1.Node，g.prioritizeNodes 会根据一些优先级算法计算不同node的得分给出这些node 的排序。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">genericScheduler</span><span class="p">)</span> <span class="nf">prioritizeNodes</span><span class="p">(</span>
 <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span>
 <span class="nx">prof</span> <span class="o">*</span><span class="nx">profile</span><span class="p">.</span><span class="nx">Profile</span><span class="p">,</span>
 <span class="nx">state</span> <span class="o">*</span><span class="nx">framework</span><span class="p">.</span><span class="nx">CycleState</span><span class="p">,</span>
 <span class="nx">pod</span> <span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">,</span>
 <span class="nx">nodes</span> <span class="p">[]</span><span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">framework</span><span class="p">.</span><span class="nx">NodeScoreList</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
 <span class="c1">// Run PreScore plugins.
</span><span class="c1"></span> <span class="nx">preScoreStatus</span> <span class="o">:=</span> <span class="nx">prof</span><span class="p">.</span><span class="nf">RunPreScorePlugins</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">)</span>
 <span class="k">if</span> <span class="p">!</span><span class="nx">preScoreStatus</span><span class="p">.</span><span class="nf">IsSuccess</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">preScoreStatus</span><span class="p">.</span><span class="nf">AsError</span><span class="p">()</span>
 <span class="p">}</span>
    
 <span class="c1">// Run the Score plugins.
</span><span class="c1"></span> <span class="nx">scoresMap</span><span class="p">,</span> <span class="nx">scoreStatus</span> <span class="o">:=</span> <span class="nx">prof</span><span class="p">.</span><span class="nf">RunScorePlugins</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">)</span>
 <span class="k">if</span> <span class="p">!</span><span class="nx">scoreStatus</span><span class="p">.</span><span class="nf">IsSuccess</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">scoreStatus</span><span class="p">.</span><span class="nf">AsError</span><span class="p">()</span>
 <span class="p">}</span>
 <span class="o">...</span>
 <span class="c1">// Summarize all scores. 汇总所有 node 的分数
</span><span class="c1"></span> <span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">framework</span><span class="p">.</span><span class="nx">NodeScoreList</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nodes</span><span class="p">))</span>
    
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nodes</span> <span class="p">{</span>
     <span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">framework</span><span class="p">.</span><span class="nx">NodeScore</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">Score</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
     <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scoresMap</span> <span class="p">{</span>
         <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Score</span> <span class="o">+=</span> <span class="nx">scoresMap</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">i</span><span class="p">].</span><span class="nx">Score</span>
     <span class="p">}</span>
 <span class="p">}</span>
 <span class="c1">// 不同的extender 使用不同的goroutine 调用Prioritize函数
</span><span class="c1"></span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">extenders</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nodes</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
     <span class="o">...</span>
 <span class="p">}</span>
 <span class="o">...</span>
 <span class="k">return</span> <span class="nx">result</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>分别调用不同 plugin 的 RunPreScorePlugins 前置评分</li>
<li>RunScorePlugins 获取每个 plugin 对每个预选节点的分数，这里主要看一下，pod 调度上去会不会跟上面的 pod 有亲和性的关系(affinity) 等。如果说前面 filter 主要是针对 node 进行评价，这里主要是针对 node 里面的 pod 进行评价。</li>
<li>上面默认会起 16 goroutine 来对每个 plugin 进行计分，返回的 scoreMap key 是 plugin, 元素是一个 nodescore list，表示对每个节点的评分。</li>
<li>然后把所有的分数汇总在 result 中</li>
<li>如果有 extender 会分别起不同的 goroutine 去调用 extender.Prioritize，结果也是汇总到 result 中。</li>
</ul>
</li>
<li>
<p>然后 host, err := g.selectHost(priorityList) 会根据前面 findNodesThatFitPod 的排序结果选择一个合适的pod。</p>
</li>
</ol>
<h3 id="scheduleonepart2">scheduleOnePart2</h3>
<p>　　继续 scheduleOne 的逻辑，这部分是指调度失败的错误处理。主要是抢占和驱逐，这部分跟上一部分的逻辑比较类似，不过输入的 nodes，会有一些过滤。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="preemption.jpg"
        data-srcset="/posts/scheduler_public/preemption.jpg, preemption.jpg 1.5x, /posts/scheduler_public/preemption.jpg 2x"
        data-sizes="auto"
        alt="/posts/scheduler_public/preemption.jpg"
        title="preemption" /></p>
<h4 id="太长不看版-1">太长不看版</h4>
<ul>
<li>首先会通过 GetUpdatedPod 更新一下 pod 的信息</li>
<li>然后 PodEligibleToPreemptOthers 看一下 pod 是否可以抢占，主要判断是不是已经抢占了</li>
<li>FindCandidates 会调用 nodesWherePreemptionMightHelp 对 node 进行预选过滤，保留硬性的过滤条件跟前面调度时 predicate 逻辑类似，selectVictims 是对 node 打分，跟前面 prioritize 类似。</li>
<li>然后 SelectCandidate 选择合适抢占的 node，这个跟前面 selectHost 类似。</li>
<li>PrepareCandidate  清出足够的空间给 pod 调度上去。 不过这里在多调度器的时候可能会有一些问题，有可能刚清出资源就被其他调度器抢走了，造成不断循环。</li>
</ul>
<h4 id="具体代码细节-1">具体代码细节</h4>
<p>pkg/scheduler/scheduler.go: scheduleOne</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="c1">// 接着 part1 部分 
</span><span class="c1"></span>	<span class="nx">scheduleResult</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">Algorithm</span><span class="p">.</span><span class="nf">Schedule</span><span class="p">(</span><span class="nx">schedulingCycleCtx</span><span class="p">,</span> <span class="nx">prof</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">nominatedNode</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
      <span class="k">if</span> <span class="nx">fitError</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">core</span><span class="p">.</span><span class="nx">FitError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">!</span><span class="nx">prof</span><span class="p">.</span><span class="nf">HasPostFilterPlugins</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">klog</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;No PostFilter plugins are registered, so no preemption will be performed.&#34;</span><span class="p">)</span>
         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
           <span class="c1">// 后处理逻辑，（preempt）在这里实现。
</span><span class="c1"></span>            <span class="nx">result</span><span class="p">,</span> <span class="nx">status</span> <span class="o">:=</span> <span class="nx">prof</span><span class="p">.</span><span class="nf">RunPostFilterPlugins</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">,</span> <span class="nx">fitError</span><span class="p">.</span><span class="nx">FilteredNodesStatuses</span><span class="p">)</span>
            <span class="o">...</span> <span class="c1">// 后处理
</span><span class="c1"></span>         <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// 记录 SchedulingFailure，pod 入队 UnschedulableQ
</span><span class="c1"></span>      <span class="nx">sched</span><span class="p">.</span><span class="nf">recordSchedulingFailure</span><span class="p">(</span><span class="nx">prof</span><span class="p">,</span> <span class="nx">podInfo</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">PodReasonUnschedulable</span><span class="p">,</span> <span class="nx">nominatedNode</span><span class="p">)</span>
      <span class="k">return</span>
   <span class="p">}</span>
</code></pre></div><ul>
<li>
<p>如果前面调度失败，会进入的处理错误逻辑，尝试调用 prof.RunPostFilterPlugins。这个是引入 scheduler framework 之后的形式，在 v1.15 之前的版本，是只有抢占的逻辑，如下 （github.com/kubernetes/kubernetes:<strong>v1.14.1</strong> ）</p>
<p>pkg/scheduler/scheduler.go: scheduleOne</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">scheduleResult</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">Algorithm</span><span class="p">.</span><span class="nf">Schedule</span><span class="p">(</span><span class="nx">schedulingCycleCtx</span><span class="p">,</span> <span class="nx">prof</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 如果调度失败
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">fitError</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">core</span><span class="p">.</span><span class="nx">FitError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">util</span><span class="p">.</span><span class="nf">PodPriorityEnabled</span><span class="p">()</span> <span class="o">||</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">DisablePreemption</span> <span class="p">{</span>
              <span class="o">...</span> <span class="c1">// 如果不允许抢占
</span><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">preemptionStartTime</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
                <span class="nx">sched</span><span class="p">.</span><span class="nf">preempt</span><span class="p">(</span><span class="nx">pod</span><span class="p">,</span> <span class="nx">fitError</span><span class="p">)</span>
                <span class="o">...</span> <span class="c1">// some metrics
</span><span class="c1"></span>            <span class="p">}</span>
            <span class="nx">metrics</span><span class="p">.</span><span class="nx">PodScheduleFailures</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">...</span> <span class="c1">// 其他错误
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="k">return</span>
    <span class="p">}</span>
</code></pre></div><p>我们还是以 v1.19.1 plugin 中的抢占逻辑进行分析。</p>
<p>pkg/scheduler/framework/plugins/defaultpreemption/default_preemption.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">pl</span> <span class="o">*</span><span class="nx">DefaultPreemption</span><span class="p">)</span> <span class="nf">preempt</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">state</span> <span class="o">*</span><span class="nx">framework</span><span class="p">.</span><span class="nx">CycleState</span><span class="p">,</span> <span class="nx">pod</span> <span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">framework</span><span class="p">.</span><span class="nx">NodeToStatusMap</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">cs</span> <span class="o">:=</span> <span class="nx">pl</span><span class="p">.</span><span class="nx">fh</span><span class="p">.</span><span class="nf">ClientSet</span><span class="p">()</span>
    <span class="nx">ph</span> <span class="o">:=</span> <span class="nx">pl</span><span class="p">.</span><span class="nx">fh</span><span class="p">.</span><span class="nf">PreemptHandle</span><span class="p">()</span>
    <span class="nx">nodeLister</span> <span class="o">:=</span> <span class="nx">pl</span><span class="p">.</span><span class="nx">fh</span><span class="p">.</span><span class="nf">SnapshotSharedLister</span><span class="p">().</span><span class="nf">NodeInfos</span><span class="p">()</span>
    
    <span class="c1">// 0) Fetch the latest version of &lt;pod&gt;.
</span><span class="c1"></span>    <span class="nx">pod</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">GetUpdatedPod</span><span class="p">(</span><span class="nx">cs</span><span class="p">,</span> <span class="nx">pod</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">klog</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Error getting the updated preemptor pod object: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    
    <span class="c1">// 1) Ensure the preemptor is eligible to preempt other pods.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">PodEligibleToPreemptOthers</span><span class="p">(</span><span class="nx">pod</span><span class="p">,</span> <span class="nx">nodeLister</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">pod</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nx">NominatedNodeName</span><span class="p">])</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
    
    <span class="c1">// 2) Find all preemption candidates.
</span><span class="c1"></span>    <span class="nx">candidates</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">FindCandidates</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cs</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">ph</span><span class="p">,</span> <span class="nx">nodeLister</span><span class="p">,</span> <span class="nx">pl</span><span class="p">.</span><span class="nx">pdbLister</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
    
    <span class="c1">// 3) Interact with registered Extenders to filter out some candidates if needed.
</span><span class="c1"></span>    <span class="nx">candidates</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">CallExtenders</span><span class="p">(</span><span class="nx">ph</span><span class="p">.</span><span class="nf">Extenders</span><span class="p">(),</span> <span class="nx">pod</span><span class="p">,</span> <span class="nx">nodeLister</span><span class="p">,</span> <span class="nx">candidates</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    
    <span class="c1">// 4) Find the best candidate.
</span><span class="c1"></span>    <span class="nx">bestCandidate</span> <span class="o">:=</span> <span class="nf">SelectCandidate</span><span class="p">(</span><span class="nx">candidates</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">bestCandidate</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">bestCandidate</span><span class="p">.</span><span class="nf">Name</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="kc">nil</span>
    <span class="p">}</span>
    
    <span class="c1">// 5) Perform preparation work before nominating the selected candidate.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">PrepareCandidate</span><span class="p">(</span><span class="nx">bestCandidate</span><span class="p">,</span> <span class="nx">pl</span><span class="p">.</span><span class="nx">fh</span><span class="p">,</span> <span class="nx">cs</span><span class="p">,</span> <span class="nx">pod</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">bestCandidate</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>抢占（preempt）的代码也比较清晰，可以参考注释来理解工作原理：</p>
<ul>
<li>
<p>首先是通过GetUpdatedPod，确认最新的 pod 的版本（保证新的改动可以被接收到）</p>
</li>
<li>
<p>然后 PodEligibleToPreemptOthers 看一下这个 pod 适不适合执行抢占，因为这个pod 有可能已经抢占过了， 然后被抢占的pod 也在 terminating 了，就不会发生抢占。</p>
</li>
<li>
<p>FindCandidates 用于找到合适被抢占的候选nodes</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Each candidate is executable to make the given &lt;pod&gt; schedulable.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">FindCandidates</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">cs</span> <span class="nx">kubernetes</span><span class="p">.</span><span class="nx">Interface</span><span class="p">,</span> <span class="nx">state</span> <span class="o">*</span><span class="nx">framework</span><span class="p">.</span><span class="nx">CycleState</span><span class="p">,</span> <span class="nx">pod</span> <span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">,</span>
    <span class="nx">m</span> <span class="nx">framework</span><span class="p">.</span><span class="nx">NodeToStatusMap</span><span class="p">,</span> <span class="nx">ph</span> <span class="nx">framework</span><span class="p">.</span><span class="nx">PreemptHandle</span><span class="p">,</span> <span class="nx">nodeLister</span> <span class="nx">framework</span><span class="p">.</span><span class="nx">NodeInfoLister</span><span class="p">,</span>
    <span class="nx">pdbLister</span> <span class="nx">policylisters</span><span class="p">.</span><span class="nx">PodDisruptionBudgetLister</span><span class="p">)</span> <span class="p">([]</span><span class="nx">Candidate</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">allNodes</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">nodeLister</span><span class="p">.</span><span class="nf">List</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allNodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">core</span><span class="p">.</span><span class="nx">ErrNoNodesAvailable</span>
    <span class="p">}</span>
        
    <span class="nx">potentialNodes</span> <span class="o">:=</span> <span class="nf">nodesWherePreemptionMightHelp</span><span class="p">(</span><span class="nx">allNodes</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
    <span class="o">...</span> 
    <span class="k">return</span> <span class="nf">dryRunPreemption</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ph</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">,</span> <span class="nx">potentialNodes</span><span class="p">,</span> <span class="nx">pdbs</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>
<p>首先 nodesWherePreemptionMightHelp 会把所有的nodes 重新查看一下，如果是因为 predicates 检查不通过的，尝试在上面去除 pod 看是否可能通过</p>
</li>
<li>
<p>然后把 pod 和 potential node 输入到 dryRunPreemption  中，dryRunPreemption 会起多个进程进行跟前面 schedule 里面 checkNode 类似，通过 checkNode 运行 <strong>selectVictimsOnNode</strong>，这个函数会尝试找到最小被抢占 pods 的集合（只要低优先级的 pods 够，就不会抢占node 内高优先级的)。</p>
</li>
<li>
<p>返回汇总后的cadidates 信息， 包括node 中被抢占 pods 的信息，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">selectVictimsOnNode</span><span class="p">(</span>
    <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span>
    <span class="nx">ph</span> <span class="nx">framework</span><span class="p">.</span><span class="nx">PreemptHandle</span><span class="p">,</span>
    <span class="nx">state</span> <span class="o">*</span><span class="nx">framework</span><span class="p">.</span><span class="nx">CycleState</span><span class="p">,</span>
    <span class="nx">pod</span> <span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">,</span>
    <span class="nx">nodeInfo</span> <span class="o">*</span><span class="nx">framework</span><span class="p">.</span><span class="nx">NodeInfo</span><span class="p">,</span>
    <span class="nx">pdbs</span> <span class="p">[]</span><span class="o">*</span><span class="nx">policy</span><span class="p">.</span><span class="nx">PodDisruptionBudget</span><span class="p">,</span>
<span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">){</span>
    <span class="o">...</span>
    <span class="c1">// 筛选被抢占的 pod
</span><span class="c1"></span>    <span class="nx">podPriority</span> <span class="o">:=</span> <span class="nx">podutil</span><span class="p">.</span><span class="nf">GetPodPriority</span><span class="p">(</span><span class="nx">pod</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nodeInfo</span><span class="p">.</span><span class="nx">Pods</span> <span class="p">{</span>
       <span class="k">if</span> <span class="nx">podutil</span><span class="p">.</span><span class="nf">GetPodPriority</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Pod</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">podPriority</span> <span class="p">{</span>
          <span class="nx">potentialVictims</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">potentialVictims</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Pod</span><span class="p">)</span>
          <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">removePod</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Pod</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
             <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
          <span class="p">}</span>
       <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 保留一些不必被抢占的，把 pod 分两类，一个是 如果抢占会造成违反了 PodDisruptionBudget(PDB) 的 pod（violatingVictims），一个是不会violatingVictims
</span><span class="c1"></span>    <span class="nx">violatingVictims</span><span class="p">,</span> <span class="nx">nonViolatingVictims</span> <span class="o">:=</span> <span class="nf">filterPodsWithPDBViolation</span><span class="p">(</span><span class="nx">potentialVictims</span><span class="p">,</span> <span class="nx">pdbs</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">violatingVictims</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">fits</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">reprievePod</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">klog</span><span class="p">.</span><span class="nf">Warningf</span><span class="p">(</span><span class="s">&#34;Failed to reprieve pod %q: %v&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">!</span><span class="nx">fits</span> <span class="p">{</span>
            <span class="nx">numViolatingVictim</span><span class="o">++</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>然后 SelectCandidate 选择最好的candidate，有一系列判断准则：</p>
<ul>
<li>
<p>这个 node 是不是满足 Pod 干扰预算的条件。</p>
</li>
<li>
<p>这个 node 是不是只需要驱逐的pod 的优先级是不是最小的</p>
</li>
<li>
<p>驱逐这些pod 这个 node affinity 有没有被影响</p>
</li>
<li>
<p>是不是驱逐的 pod 数目最小</p>
<p>&hellip;</p>
</li>
</ul>
</li>
<li>
<p>PrepareCandidate 会驱逐 victims pod，如果这些 pod 在waitting，不给调度，清楚他们的nominatedNodeName，如果有比较低优先级的pods 被提名到这个 node 会不合适。</p>
</li>
</ul>
</li>
</ul>
<h3 id="scheduleonepart3">scheduleOnePart3</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="binding.png"
        data-srcset="/posts/scheduler_public/binding.png, binding.png 1.5x, /posts/scheduler_public/binding.png 2x"
        data-sizes="auto"
        alt="/posts/scheduler_public/binding.png"
        title="binding" /></p>
<h4 id="具体代码细节-2">具体代码细节</h4>
<p>pkg/scheduler/scheduler.go: scheduleOne</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">   <span class="nx">scheduleResult</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">Algorithm</span><span class="p">.</span><span class="nf">Schedule</span><span class="p">(</span><span class="nx">schedulingCycleCtx</span><span class="p">,</span> <span class="nx">prof</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">pod</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span><span class="o">...</span><span class="p">}</span>
   <span class="o">...</span>
   <span class="c1">// 1. assume 设置 schedulerCache 
</span><span class="c1"></span>   <span class="nx">err</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nf">assume</span><span class="p">(</span><span class="nx">assumedPod</span><span class="p">,</span> <span class="nx">scheduleResult</span><span class="p">.</span><span class="nx">SuggestedHost</span><span class="p">)</span>
   <span class="o">...</span>
   <span class="c1">// 2. reserve 预留 volume 等改动
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">sts</span> <span class="o">:=</span> <span class="nx">prof</span><span class="p">.</span><span class="nf">RunReservePluginsReserve</span><span class="p">(</span><span class="nx">schedulingCycleCtx</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">assumedPod</span><span class="p">,</span> <span class="nx">scheduleResult</span><span class="p">.</span><span class="nx">SuggestedHost</span><span class="p">);</span> <span class="p">!</span><span class="nx">sts</span><span class="p">.</span><span class="nf">IsSuccess</span><span class="p">()</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
   <span class="c1">// 3. 是否满足 permit 条件 
</span><span class="c1"></span>   <span class="nx">runPermitStatus</span> <span class="o">:=</span> <span class="nx">prof</span><span class="p">.</span><span class="nf">RunPermitPlugins</span><span class="p">(</span><span class="nx">schedulingCycleCtx</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">assumedPod</span><span class="p">,</span> <span class="nx">scheduleResult</span><span class="p">.</span><span class="nx">SuggestedHost</span><span class="p">)</span>
   <span class="c1">// bind the pod to its host asynchronously (we can do this b/c of the assumption step above).
</span><span class="c1"></span>   <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">bindingCycleCtx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
      <span class="c1">// 等待 permit 条件完备
</span><span class="c1"></span>      <span class="nx">waitOnPermitStatus</span> <span class="o">:=</span> <span class="nx">prof</span><span class="p">.</span><span class="nf">WaitOnPermit</span><span class="p">(</span><span class="nx">bindingCycleCtx</span><span class="p">,</span> <span class="nx">assumedPod</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">waitOnPermitStatus</span><span class="p">.</span><span class="nf">IsSuccess</span><span class="p">()</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
      <span class="c1">// Run &#34;prebind&#34; plugins.
</span><span class="c1"></span>      <span class="nx">preBindStatus</span> <span class="o">:=</span> <span class="nx">prof</span><span class="p">.</span><span class="nf">RunPreBindPlugins</span><span class="p">(</span><span class="nx">bindingCycleCtx</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">assumedPod</span><span class="p">,</span> <span class="nx">scheduleResult</span><span class="p">.</span><span class="nx">SuggestedHost</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">preBindStatus</span><span class="p">.</span><span class="nf">IsSuccess</span><span class="p">()</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
      <span class="c1">// 5. 绑定 pod 和 node
</span><span class="c1"></span>      <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="nx">bindingCycleCtx</span><span class="p">,</span> <span class="nx">prof</span><span class="p">,</span> <span class="nx">assumedPod</span><span class="p">,</span> <span class="nx">scheduleResult</span><span class="p">.</span><span class="nx">SuggestedHost</span><span class="p">,</span> <span class="nx">state</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
		<span class="o">...</span> <span class="c1">// some metrics
</span><span class="c1"></span>         <span class="c1">// Run &#34;postbind&#34; plugins.
</span><span class="c1"></span>         <span class="nx">prof</span><span class="p">.</span><span class="nf">RunPostBindPlugins</span><span class="p">(</span><span class="nx">bindingCycleCtx</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">assumedPod</span><span class="p">,</span> <span class="nx">scheduleResult</span><span class="p">.</span><span class="nx">SuggestedHost</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}()</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>
<p>如果前面 part1 schedule 的 sched.Algorithm.Schedule 调度算法调度成功，scheduleResult 返回一个建议调度的node，然后调用 sched.assume，这里主要是在 cache 中记录这个 pod 为已经调度了，这样下次调度的时候就不会重新调度一次这个 pod。</p>
</li>
<li>
<p>然后会调用，RunReservePluginsReserve，RunPermitPlugins，这些 plugins 设置的位点，我们假设没有plugins 设置了先跳过。</p>
<ul>
<li>reserve 会执行像 AssumePodVolumes 等，除了 pod assume 之外需要在 cache 保留的操作，unreserve 类似。</li>
</ul>
</li>
<li>
<p>RunPermitPlugins 会成为bind 的准入，就是前面reserve 之后相关的资源就不会被使用了，不过还有一些条件没有满足，所以不可以 bind，就是为了占着资源，类似 gang-scheduling 的时候会用到。</p>
</li>
<li>
<p>就会进入绑定的逻辑（bind），bind 会另外起一个 goroutine 所以到这里，scheduleOne 就会到下一个调度循环了，使用这样的做法是 bind 实际上比较耗时，所以使用另外的进程进行，不会阻塞到调度，不过有趣的是在早期的 scheduler，并不是一开始就是这样的结构的，如v1.0.0 的版本中，调度完之后会直接 binding，会有比较大性能的损耗。</p>
<p>plugin/pkg/scheduler/scheduler.go 这时 scheduler 还在 plugins 中</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Scheduler</span><span class="p">)</span> <span class="nf">scheduleOne</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">dest</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Algorithm</span><span class="p">.</span><span class="nf">Schedule</span><span class="p">(</span><span class="nx">pod</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">MinionLister</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="nx">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">api</span><span class="p">.</span><span class="nx">Binding</span><span class="p">{</span>
       <span class="nx">ObjectMeta</span><span class="p">:</span> <span class="nx">api</span><span class="p">.</span><span class="nx">ObjectMeta</span><span class="p">{</span><span class="nx">Namespace</span><span class="p">:</span> <span class="nx">pod</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">,</span> <span class="nx">Name</span><span class="p">:</span> <span class="nx">pod</span><span class="p">.</span><span class="nx">Name</span><span class="p">},</span>
       <span class="nx">Target</span><span class="p">:</span> <span class="nx">api</span><span class="p">.</span><span class="nx">ObjectReference</span><span class="p">{</span>
          <span class="nx">Kind</span><span class="p">:</span> <span class="s">&#34;Node&#34;</span><span class="p">,</span>
          <span class="nx">Name</span><span class="p">:</span> <span class="nx">dest</span><span class="p">,</span>
       <span class="p">},</span>
    <span class="p">}</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Modeler</span><span class="p">.</span><span class="nf">LockedAction</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
       <span class="nx">bindingStart</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
       <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Binder</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
       <span class="nx">metrics</span><span class="p">.</span><span class="nx">BindingLatency</span><span class="p">.</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">metrics</span><span class="p">.</span><span class="nf">SinceInMicroseconds</span><span class="p">(</span><span class="nx">bindingStart</span><span class="p">))</span>
       <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
       <span class="nx">assumed</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">pod</span>
       <span class="nx">assumed</span><span class="p">.</span><span class="nx">Spec</span><span class="p">.</span><span class="nx">NodeName</span> <span class="p">=</span> <span class="nx">dest</span>
       <span class="nx">s</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Modeler</span><span class="p">.</span><span class="nf">AssumePod</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">assumed</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>sched.bind 首先 WaitOnPermit 会查看一下 permit 是否完成，前面 permit 实际上是在这里被挡住</p>
</li>
<li>
<p>然后会运行一些 prebind 的操作，像网络配置，存储配置等，像volumeBinder 会</p>
<ul>
<li>init volume bind, pv -&gt; pvc</li>
<li>触发 volume provisioning</li>
<li>等待 pvc binding 完成</li>
</ul>
</li>
<li>
<p>Prebind 成功就会 Bind， pod -&gt; node，defaultBinder 就很简单</p>
<p>pkg/scheduler/framework/plugins/defaultbinder/default_binder.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Bind binds pods to nodes using the k8s client.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">DefaultBinder</span><span class="p">)</span> <span class="nf">Bind</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">state</span> <span class="o">*</span><span class="nx">framework</span><span class="p">.</span><span class="nx">CycleState</span><span class="p">,</span> <span class="nx">p</span> <span class="o">*</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Pod</span><span class="p">,</span> <span class="nx">nodeName</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">framework</span><span class="p">.</span><span class="nx">Status</span> <span class="p">{</span>
   <span class="nx">binding</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">v1</span><span class="p">.</span><span class="nx">Binding</span><span class="p">{</span>
      <span class="nx">ObjectMeta</span><span class="p">:</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">ObjectMeta</span><span class="p">{</span><span class="nx">Namespace</span><span class="p">:</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">,</span> <span class="nx">Name</span><span class="p">:</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">UID</span><span class="p">:</span> <span class="nx">p</span><span class="p">.</span><span class="nx">UID</span><span class="p">},</span>
      <span class="nx">Target</span><span class="p">:</span>     <span class="nx">v1</span><span class="p">.</span><span class="nx">ObjectReference</span><span class="p">{</span><span class="nx">Kind</span><span class="p">:</span> <span class="s">&#34;Node&#34;</span><span class="p">,</span> <span class="nx">Name</span><span class="p">:</span> <span class="nx">nodeName</span><span class="p">},</span>
   <span class="p">}</span>
   <span class="c1">// 创建 bind
</span><span class="c1"></span>   <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">handle</span><span class="p">.</span><span class="nf">ClientSet</span><span class="p">().</span><span class="nf">CoreV1</span><span class="p">().</span><span class="nf">Pods</span><span class="p">(</span><span class="nx">binding</span><span class="p">.</span><span class="nx">Namespace</span><span class="p">).</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">binding</span><span class="p">,</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">CreateOptions</span><span class="p">{})</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">framework</span><span class="p">.</span><span class="nf">NewStatus</span><span class="p">(</span><span class="nx">framework</span><span class="p">.</span><span class="nx">Error</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>如果成功会 RunPostBindPlugin，暂时没有 default 的 postBindPlugin.</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>​　　总体上说，kube-scheduler 的工作方式和其他的 controller 并没有什么不同。如果把 scheduler 看成是一个黑盒的话， 可以认为 scheduler 的输入是一个个的 Pod，输出就是这个Pod 和某个节点 node 的绑定(Bind)，如果是 controller 可能是输入一个资源，出去的是更新之后资源。它不对绑定成功与否负责，只是作为资源的分配者。某程度上，没有 scheduler 的话 kubernetes 也能正常运行，只需要手动创建 pod，然后使用 client 执行 <code>CoreV1().Pods(binding.Namespace).Bind(ctx, binding, metav1.CreateOptions{})</code> 基本等同于实现了scheduler 的功能。</p>
<p>​　　kube-scheduler 的设计比较简单，在多个版本的迭代中，其基本的逻辑没有特别大的变化，都是笨笨地一个个 pod 入队处理，我们在文中也穿插了一些相关的内容。我自己暂时感觉这部分还不是写得特别好，一个自己的功力还不够，一个是自己可以了解到的线索也太少，希望后续的更新可以完善。提出这个部分，我自己的思考是了解一下 kube-scheduler 的发展，顺便窥见软件工程的迭代概貌。我自己的理解是大致上都会遵循这样的一个历程：可用性 -&gt; 性能优化 -&gt; 可扩展性，然后在迭代的过程中保持稳定性。</p>
<p>　　另外，这里我刻意地把 plugins 和 extender 的部分进行了删减，一个是为了控制篇幅，一个是希望把这些可以 custom 的部分留待下一部分的 scheduler-framework 一并讲述。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p><a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener noreffer">kubernetes</a></p>
</li>
<li>
<p><a href="https://kubernetes.io/docs/concepts/scheduling-eviction/" target="_blank" rel="noopener noreffer">kubernetes 调度与驱逐</a></p>
</li>
<li>
<p><a href="https://www.infoq.cn/article/CHGOHJ8ybvXuEmhy1SFy" target="_blank" rel="noopener noreffer">kube-scheduler 源码解析</a></p>
</li>
<li>
<p><a href="https://book.douban.com/subject/35100082/" target="_blank" rel="noopener noreffer">Kubernetes源码剖析</a></p>
</li>
<li>
<p><a href="https://github.com/kubernetes/community" target="_blank" rel="noopener noreffer">Kubenetes community</a></p>
</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-01-16</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/horovod_public/" class="prev" rel="prev" title="Horovod 源码分析"><i class="fas fa-angle-left fa-fw"></i>Horovod 源码分析</a>
            <a href="/posts/scheduler_framework/" class="next" rel="next" title="Scheduler Framework 源码分析">Scheduler Framework 源码分析<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.74.1">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank"></a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
